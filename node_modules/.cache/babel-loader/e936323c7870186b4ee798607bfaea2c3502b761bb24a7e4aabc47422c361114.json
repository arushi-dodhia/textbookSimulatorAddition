{"ast":null,"code":"export function add(binary1, binary2) {\n  if (!/^[01]+$/.test(binary1) || !/^[01]+$/.test(binary2)) {\n    return {\n      result: \"Invalid binary input\",\n      steps: []\n    };\n  }\n  const maxLength = Math.max(binary1.length, binary2.length);\n  binary1 = binary1.padStart(maxLength, \"0\");\n  binary2 = binary2.padStart(maxLength, \"0\");\n  let carry = 0;\n  let result = \"\";\n  let steps = [];\n  for (let i = maxLength - 1; i >= 0; i--) {\n    const bit1 = parseInt(binary1[i], 10);\n    const bit2 = parseInt(binary2[i], 10);\n    const sum = bit1 + bit2 + carry;\n    result = sum % 2 + result; // Result bit is sum mod 2\n    carry = Math.floor(sum / 2); // Carry for next bit\n    steps.push(`Step ${maxLength - i}: ${binary1[i]} + ${binary2[i]} + carry(${carry}) = ${sum} -> result: ${result}`);\n  }\n  if (carry > 0) {\n    result = carry + result; // Add the carry if it exists\n    steps.push(`Final carry: ${carry}, result: ${result}`);\n  }\n  return {\n    result,\n    steps\n  };\n}\nexport function subtract(binary1, binary2) {\n  // Make sure both inputs are valid binary numbers\n  if (!/^[01]+$/.test(binary1) || !/^[01]+$/.test(binary2)) {\n    return {\n      result: \"Invalid binary input\",\n      steps: []\n    };\n  }\n  const maxLength = Math.max(binary1.length, binary2.length);\n  binary1 = binary1.padStart(maxLength, \"0\");\n  binary2 = binary2.padStart(maxLength, \"0\");\n  let borrow = 0;\n  let result = \"\";\n  let steps = [];\n  for (let i = maxLength - 1; i >= 0; i--) {\n    let bit1 = parseInt(binary1[i], 10);\n    let bit2 = parseInt(binary2[i], 10);\n    bit1 -= borrow; // Apply previous borrow if any\n\n    if (bit1 < bit2) {\n      bit1 += 2; // Borrow from the next bit\n      borrow = 1;\n    } else {\n      borrow = 0;\n    }\n    result = bit1 - bit2 + result; // Result bit is bit1 - bit2\n    steps.push(`Step ${maxLength - i}: ${binary1[i]} - ${binary2[i]} - borrow(${borrow}) = ${bit1 - bit2} -> result: ${result}`);\n  }\n  return {\n    result,\n    steps\n  };\n}","map":{"version":3,"names":["add","binary1","binary2","test","result","steps","maxLength","Math","max","length","padStart","carry","i","bit1","parseInt","bit2","sum","floor","push","subtract","borrow"],"sources":["/Users/arushidodhia/Desktop/252textbook/addandsubtract/src/addorsubtract.jsx"],"sourcesContent":["\nexport function add(binary1, binary2) {\n\n  if (!/^[01]+$/.test(binary1) || !/^[01]+$/.test(binary2)) {\n    return { result: \"Invalid binary input\", steps: [] };\n  }\n\n  const maxLength = Math.max(binary1.length, binary2.length);\n  binary1 = binary1.padStart(maxLength, \"0\");\n  binary2 = binary2.padStart(maxLength, \"0\");\n\n  let carry = 0;\n  let result = \"\";\n  let steps = [];\n\n  for (let i = maxLength - 1; i >= 0; i--) {\n    const bit1 = parseInt(binary1[i], 10);\n    const bit2 = parseInt(binary2[i], 10);\n    const sum = bit1 + bit2 + carry;\n    \n    result = (sum % 2) + result; // Result bit is sum mod 2\n    carry = Math.floor(sum / 2); // Carry for next bit\n    steps.push(`Step ${maxLength - i}: ${binary1[i]} + ${binary2[i]} + carry(${carry}) = ${sum} -> result: ${result}`);\n  }\n\n  if (carry > 0) {\n    result = carry + result; // Add the carry if it exists\n    steps.push(`Final carry: ${carry}, result: ${result}`);\n  }\n\n  return { result, steps };\n}\n\nexport function subtract(binary1, binary2) {\n  // Make sure both inputs are valid binary numbers\n  if (!/^[01]+$/.test(binary1) || !/^[01]+$/.test(binary2)) {\n    return { result: \"Invalid binary input\", steps: [] };\n  }\n\n  const maxLength = Math.max(binary1.length, binary2.length);\n  binary1 = binary1.padStart(maxLength, \"0\");\n  binary2 = binary2.padStart(maxLength, \"0\");\n\n  let borrow = 0;\n  let result = \"\";\n  let steps = [];\n\n  for (let i = maxLength - 1; i >= 0; i--) {\n    let bit1 = parseInt(binary1[i], 10);\n    let bit2 = parseInt(binary2[i], 10);\n\n    bit1 -= borrow; // Apply previous borrow if any\n\n    if (bit1 < bit2) {\n      bit1 += 2; // Borrow from the next bit\n      borrow = 1;\n    } else {\n      borrow = 0;\n    }\n\n    result = (bit1 - bit2) + result; // Result bit is bit1 - bit2\n    steps.push(`Step ${maxLength - i}: ${binary1[i]} - ${binary2[i]} - borrow(${borrow}) = ${bit1 - bit2} -> result: ${result}`);\n  }\n\n  return { result, steps };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}